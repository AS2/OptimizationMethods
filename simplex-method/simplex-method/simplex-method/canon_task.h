#pragma once

#include <vector>
#include <string>

#include "error.h"

// DK2: КОГДА БУДЕШЬ РЕАЛИЗОВЫВАТЬ КЛАССЫ С МЕТОДАМИ, НАПИШИ ТАМ friend ОТ ЭТОГО КЛАССА, ЧТОБ МНЕ УБОГИЕ СЕТТЕРЫ-ГЕТТЕРЫ НЕ ДЕЛАТЬ

class canon_task {
private:
  // ДАННЫЕ ДЛЯ РЕАЛИЗАЦИИ СИМПЛИКС-МЕТОДА и МЕТОДА ПЕРЕБОРА ОПОРНЫХ ВЕКТОРОВ
  size_t N, B;                          // исходное число переменных и число ограничений в виде неравенств

  // ВЕКТОР СТРОК (ограничений), СОСТОЯЩИЙ ИЗ КОЭФ
  std::vector<std::vector<double>> A;   // коэффициенты при неизвестных матрицы ограничений в виде неравенств 
                                        // (или коэффициенты при неизвестных у ограничений в виде равенств у канонической формы записи задачи Л.П.)

  std::vector<double> b;                // свободные коэфициенты, находящиеся в правой части неравенств "меньше-равно" 
                                        // (или свободные члены для новых переменных, образованных от неравеств для приведения в каноническую форму)

  std::vector<double> c;                // коэффициенты при неизвестных целевой функции максимизации

  double v;                             // свободный член целефой функции максимизации

  // ВСПОМОГАТЕЛЬНЫЕ ДАННЫЕ ДЛЯ СВЕРТКИ ВЕКТОРА ЗНАЧЕНИЙ НЕИЗВЕСТНЫХ СТАНДАРТНОГО (КАНОНИЧЕСКОГО) ВИДА ЗАДАЧИ Л.П.
  // В ВЕКТОР ЗНАЧЕНИЙ НЕИЗВЕСТНЫХ ВХОДНОЙ ЗАДАЧИ Л.П.
  size_t originalN;
  std::vector<std::vector<size_t>> fakesValuesIndexes; // вектор троек индексов: 0-ой индекс - индекс исходной неизвестной, 1 и 2 индекс - индексы неизвестных в векторе, на которые разделилось неизвестное в ходе замены переменной
public:
  canon_task() = delete;

  // ОСНОВНАЯ ФУНКЦИЯ ДЛЯ ВЫЗОВА, ОНА СРАЗУ ВСЕ СДЕЛАЕТ ТАК КАК НУЖНО (Я НАДЕЮСЬ)
  canon_task(std::string& fileName);

  // ПОСЛЕ НАЙДЕННОГО РЕШЕНИЯ КАКИМ ЛИБО МЕТОДОМ, ПРОСУНЬ ЭТО РЕШЕНИЕ СЮДА, ЧТОБ ПОЛУЧИТЬ УЖЕ РЕЩЕНИЕ ИСХОДНОЙ ЗАДАЧИ
  std::vector<double> vectorConvolutional(std::vector<double>& vectorToConvolute);

  void print();
};
